# Progress

## Brief
The aim is to build a quote builder - a builder goes on-site builds up a quote for the customer at the end this is emailed to them and the quote stored for follow up or acceptance at a later date.

Use a vue interface to make this reactive, the page shouldn't reload between adding and removing items, the total should automatically update on item adding/removal/quantity change.

Build a quote wizard builder with the following functionality
    ability to create products
    ability to create and edit a quote
    ability to assign and remove products on a quote
    ability to increase and decrease line item quantity
    sub-total, vat total and total to automatically update on the quote when adding/removing/editing line items
    ability to send a quote to the customer (send this to mailtrap)
    cron that runs at the end of the day to give an overview of the quotes created that day with totals via email

## Plan
Product:
    Name
    Price

Quote:
    Customer name
    Customer email

ProductInQuote:
    Product (ref)
    Quote (ref)
    Count


A quote has many products, each product


## Done
I created a new Laravel 7 project.
I installed the UI package.
I added Vue UI scaffolding for user authorisation.
I added a User seeder that creates a sample account.
I confirmed I could use the basic (non-Vue) user interface to log in.

I created a factory and seeder for Products, and confirmed they created valid data that can be accessed through the Product model.
I created a simple Vue component and added it to a Blade template.
I added an API route that returns all Products.
I used Axios to make the Vue component fetch data from that API route.
I made the Vue component show the names of those fetched products as a simple list.

I installed and set up vue-routes.
I created sample routes and views using Vue.
I added a SpaController and a catch-all route in Laravel that directs all requests to the front end's single page application.
I added the component that fetches and displays a list of products to a Vue view.

I added an API end point and controller action for adding a product.
I added validation rules for creating a product.
I created a basic Vue form for creating a new product, which submits the data as a POST request to the correct endpoint on the Laravel API.

The Vue frontend can add products and have them listed without the page ever needing to reload, but it doesn't handle validation errors it receives back from the backend. I'll be working on that next.

I examined the object provided by Axios when a request results in an error, and found how to access any validation error messages.
I added to the ProductAdd Vue component so it can extract and display validation errors next to the relevant form field.
I extracted the error display into its own Vue component.
I found an issue where entering a product price of "abc" displays the validation error that a product price is required, rather than the specific "must be a number" error.
I examined the XHR requests being sent, and when entered as text the price value was being transmitted as blank.
I found the cause to be a maths operation in JavaScript which was silently converting a string value into blank.
I resolved the issue by transmitting the content as it is in the field, so the correct validation check can be triggered.

The frontend is now receiving and displaying the validation errors generated by Laravel. Next I will add the ability to edit and delete products.

I added the route and controller action for deleting a product to the Laravel backend.
I added a method and button to the Vue frontend which sends a delete request to the API endpoint.
I tested that it's now possible to delete Products, and that the deletion is reflected in the database contents.
I reviewed how changes flow from parent to child components through props. Changes on a child component will not flow back up to the parent, so how I had planned to structure components to reuse one for both editing and creating a product will need some adapting.

I reworked the add product front end to work with a reusable product form.
I began creating the edit product front end with the reusable form, but found that reusing a fairly small amount of template code needed a lot of much more complex script code. So I changed how the components are structured so there's just two separate forms for creating and editing a product. The more complex tasks such as validation are still shared.
I created the frontend component for editing a product.
I added the backend route and controller actions to fetch information for a single product and to edit a product.
I confirmed that products can now be listed, created, edited, and deleted, all from the Vue single page application.

I created migrations for quotes and "products_in_quotes" tables that will be used to store quotes, each made up of a number of products.
I created the models for quote and productInQuote, with relationships which link the quote to products in a many to many relationship with a per-item count value also stored.
I began work on the controller for the quote.

Now that I have products working from the frontend to the back, I will be moving to creating the quote next.

I created a factory and seeder for quοtes.
I created controller actions for quοtes, which handle the quοte itself rather than the products attached to that quote.
I found an issue with the database migrations, where refreshing the migration would fail.
Solved migration issue, which was caused by a migration's "down" method trying to remove the wrong table.
I added an action to the ProductsInQuotes controller to add a new product to a quote.
I began testing the controller, and found an issue where the ProductInQuote model doesn't seem to have the fields expected of it, which is preventing it being able to be stored in the product_in_quotes table.

I resolved the issue with creating new ProductInQuotes. The API can now add products to a quote, setting a count for the product in that quote.

I reviewed the work remaining on this task and attempted to make some time estimates:
- Complete the backend support for managing products in a quote including price totals. At least some automated feature tests. Estimate about 5 hours.
- Add frontend support for managing quotes and products in quotes. Mostly reusing concepts from the Product frontend. About 2 hours. An extra hour to add some basic styling.
- Generate an email giving quote details to the customer. Will need to do research on generating (using Blade?) and sending emails from within Laravel. Estimate 3 hours.
- Daily cron that emails out a summary of quotes. Will need research on creating cron jobs from Laravel. Estimate 3 hours.

I added frontend support for showing a list of all quotes.
I added frontend support along with the backend routes they use for creating, editing, and deleting quotes.
I resolved some issues with how the relationship between a quote and its products was being resolved.
I added basic frontend support for listing the products that are in a quote. Confirmed that a quote created in the database appears correctly in the frontend.

Next I will be adding support for manipulating the products in a quote.

I added frontend logic for creating a dropdown menu listing all the existing products.
I added a filter to only show the products which aren't already in the quote. As this depends on data that has to first be fetched, async/await and Promise.all is used to make sure the filtered list is generated only after the data is available.

I added validation for use when updating the products in a quote.
I added the ability to add and subtract from the count of a product in the quote. On reaching zero count it is handled on the backend as a removal.
I added a button to directly remove a product from the quote.
I added some validation in addition to the backend validation to avoid entering a negative or fractional count for a product being added.
I used computed values in Vue to show a live-preview of the updated line price when preparing to add a product to the quote.
I added the ability to add a new product to the quote after selecting it from a dropdown menu and picking a quantity to add.

I changed the scripts for adding, removing, and updating the products on a quote. It now locally updates the quote as soon as the button is pressed, rather than waiting for a response back from the server providing the new information. The quote builder screen is now much nicer to work with when using browser tools to simulate a slow connection.
I also adjusted the frontend to make fewer GET requests when working on a quote. It now only requests data when a product is added or removed, not for every change in count.

I added calculation of sub-total, VAT total, and grand total to the front end.
+28min


## To Do
quote:
    sub-total, vat total and total

Frontend, on quote there's "product" and "productInQuote" object which are similar but not the same. Improve that somehow?

A "sync with server" button? Trigger a GET of the quote.

Stuff like totals could be functions on the Quote model?

Combine the quote editing screens into one, rather than jumping between pages.

factory to generate some sample ProductInQuote instances

Frontend force the price field to only take numbers (with decimal)

Load products from some external source (CSV?)

"Resources" may be useful? https://laravel.com/docs/7.x/eloquent-resources
Seems to define a mapping between Eloquent model and JSON, or other representation.
...although for basic models that's automatically done so not much advantage.

email a quote to the customer (send to mailtrap)

cron that runs at the end of the day to give an overview of the quotes created that day with totals sent via email

## Notes
To access database directly:
```
& "C:/Program Files/sqlite3/sqlite3" database/database.sqlite
.headers on
.mode column
```

Run the seeder:
```
php artisan migrate:refresh --seed
```

Removed (dev) dependences:
"bootstrap": "^4.0.0",
"jquery": "^3.2",
"lodash": "^4.17.13",
"popper.js": "^1.12",

## Some reference sources
https://www.youtube.com/watch?v=hbq2CAHNRZM
https://laravel-news.com/using-vue-router-laravel
https://vuejs.org/v2/guide/
https://laravel.com/docs/7.x

## Questions
What's the deal with naming Vue components? I seem to be able to use <product-list> and <ProductList> interchangably.
    kebab-case is recommended for custom XHTML (or XML generally?) tags. It looking different from real HTML is very much intended.

What more can I do with the Vue.use() static method? Currently used for telling it to use vue-router

On success, what should Laravel be returning as a response?
    Been doing stuff like: return response('', Response::HTTP_NO_CONTENT);

How to combine/inherit/something validation rules in Laravel.



When taking input for creating a "product in quote" it'll receive an ID for each. Should FormRequest-type validation handle checking that those IDs exist on the relevant tables? It'll get checked by the database-level foreign key enforcement. But would be nice to have a more human-friendly check first. Remember (and note in comment) that some other user could be logged in that deleted a product/quote in the time between a dropdown being populated and the dropdown being used.

I define some relationships in ProductInQuote, am I doing that in some way the wrong way around? Feels like if I defined it from the direction, I wouldn't have to specify column names for the columns.

Which is better API design?
- Separate endpoints for adding an item, removing an item, and changing the item's count
- Single endpoint for setting item count, which adds or removes as necessary.